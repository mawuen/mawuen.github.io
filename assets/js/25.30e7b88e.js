(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{477:function(e,t,s){"use strict";s.r(t);var n=s(7),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" INTRODUCTION")]),e._v(" "),s("p",[e._v("As part of a project dealing with implementing algorithm to do some\narithmetic on numbers of arbitrary size, arbitrary base and arbitrary\nsymbols, I had to think about how to write a flexible lexer, capable of\ncutting very quickly stream of characters (an arithmetic expression) in\ntokens understandable by a parser. So I will write some various articles\non the lexer, parser and evaluation of an arithmetic expression by\nmaking it a point to highlight the various optimizations that I made in\nthe algorithms to make them as fast as possible. The language used is\nC++, but since our priority is to reach the best performances possible,\nwe will avoid too costly features such as inheritance, virtual class,\netc. .. This article will details the following points:")]),e._v(" "),s("ol",[s("li",[e._v("Input and number representation.")]),e._v(" "),s("li",[e._v("Memory management.")]),e._v(" "),s("li",[e._v("The Lexer.")])]),e._v(" "),s("h3",{attrs:{id:"input-and-number-representation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#input-and-number-representation"}},[e._v("#")]),e._v(" Input and number representation")]),e._v(" "),s("p",[e._v("In order not to lose precious seconds in unnecessary operations such as\nresizing of string, repeated IO operations, etc… An expression input\nwill consist of:")]),e._v(" "),s("ol",[s("li",[e._v("Length of the base.")]),e._v(" "),s("li",[e._v("Symbols of the base.")]),e._v(" "),s("li",[e._v("Length of the arithmetic expression.")]),e._v(" "),s("li",[e._v("The arithmetic expression, without blank characters..")])]),e._v(" "),s("p",[e._v("A correct input could be:")]),e._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),e._v(" abcde "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" bc+bca+dec\n")])])]),s("p",[e._v("So we can easily read the input data with the following code:")]),e._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),e._v(" newline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Read the base size")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" base_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">>")]),e._v(" base_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("newline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Read the base's symbols")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" base "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" new "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("base_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("read")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("base"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" base_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nbase"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("base_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'\\0'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Read the expression's size")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" expr_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">>")]),e._v(" expr_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("newline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Read the expression")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" expr "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" new "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("expr_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("read")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" expr_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nexpr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("expr_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'\\0'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("The variable named newline will only be used to « absorb » the \\n at\nthe end of each line. Our expression is represented as a simple array\nof characters (we could have done the same thing in C). If you want to\ncompile the code above, do not forget to add a")]),e._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[e._v("#"),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("<iostream>")])]),e._v("\n")])])]),s("p",[e._v("at the top of your file.")]),e._v(" "),s("p",[e._v("Since the role of the lexer is to « cut » our expression into\ntokens (numbers, operators, parentheses), we must ask ourself in what\nform we will store our numbers, which tokens we will use, etc… It\nwould be tempting to create a string and to copy the number value\nthere, it would be the most intuitive. But since we are looking\nfor maximum performances, we will avoid as possible to use dynamic\nmemory allocation. Instead we will represent our number as a pair of\nintegers (offset, size) representing the beginning of the number in the\nexpression (i.e. the index of its first digit in the array representing\nthe expression) and its length. So we can work directly on the string\ncontaining the arithmetic expression.")]),e._v(" "),s("p",[e._v("Concerning tokens, we can use a simple enumeration containing an entry for each symbol:")]),e._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typedef")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v("  offset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v("  size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" s_number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typedef")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("enum")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  PLUS    "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  MINUS   "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  MULT    "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  DIV     "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  MOD     "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  LPAR    "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  RPAR    "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  NUMBER  "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" e_token"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("We will see later why each field of the list is associated with a number.")]),e._v(" "),s("h3",{attrs:{id:"memory-management"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#memory-management"}},[e._v("#")]),e._v(" Memory management")]),e._v(" "),s("p",[e._v("We will try as much as possible to do it without dynamic memory\nallocation. Our couples (offset, size) and our tokens are then stored\non the stack, using the static allocation, avoiding calls to new/delete\nand malloc/free. As we are using the string containing the expression\nto store our intermediate results, our memory consumption will be\noptimized. We must therefore adapt our algorithms for arithmetic in\norder to store the results directly in the string representing the\nexpression.")]),e._v(" "),s("h3",{attrs:{id:"the-lexer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-lexer"}},[e._v("#")]),e._v(" The Lexer")]),e._v(" "),s("p",[e._v("We will create a "),s("code",[e._v("Lexer class")]),e._v(", containing methods for lexing and some\nprivate variables such as the string containing the expression, the\ncurrent offset, etc. ..")]),e._v(" "),s("p",[e._v("The use of an object has several advantages in our case:")]),e._v(" "),s("ol",[s("li",[e._v("This prevents parsing functions to take a lot of arguments (with\nthe object of type "),s("code",[e._v("Lexer")]),e._v(", we can afford to give a single argument to\nfunctions).")]),e._v(" "),s("li",[e._v("To determine the next token, the lexer needs some informations,\nincluding the expression, the offset, the variable used to return\nthe possible pair (offset, size) representing a number, etc. .. All\nvariables can be stored in the object.")]),e._v(" "),s("li",[e._v("This makes the code more readable, without reducing the performances\nof the program.")])]),e._v(" "),s("p",[e._v("Our "),s("code",[e._v("Lexer")]),e._v(" will be defined as follows:")]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Lexer\n{\n  public:\n    Lexer (char* expr, char* table,\n           unsigned expr_size, char* op)\n      : num_ (s_number ()),\n        expr_ (expr),\n        offset_ (0),\n        table_ (table),\n        expr_size_ (expr_size),\n        op_ (op) {}\n    ~Lexer () {}\n\n    unsigned get_token ();\n\n    s_number num_;\n\n  private:\n\n    int\n    get_op_ (char c)\n    {\n      return (int)op_[(int)c];\n    }\n\n    char* expr_;\n    unsigned offset_;\n    char* table_;\n    unsigned expr_size_;\n    char* op_;\n};\n")])])]),s("p",[e._v("You have probably noticed that the constructor of our object "),s("code",[e._v("Lexer")]),e._v(" takes\ntwo string parameters named respectively, « table » and « op ». Why\nare they useful ?")]),e._v(" "),s("p",[s("strong",[e._v("Table")]),e._v(" - Since our program must be able to handle numbers represented\nin an arbitrary base with a set of arbitrary symbols, it would be\nvery difficult to evaluate expressions without modification to make\nthem easier to compute. So we’re going (during lexing) to transform\nnumbers by changing the symbols which they are composed of by a set of\ncontiguous numbers starting from 0 and up to (base_size – 1). For\nexample:")]),e._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[e._v("Old base "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(":")]),e._v(" abcde\nNew base "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(":")]),e._v(" 01234\n")])])]),s("p",[e._v("It does not change the size of the base, but just the symbols, by this\nwait it becomes easier to perform arithmetic operations on numbers.")]),e._v(" "),s("p",[s("strong",[e._v("Op")]),e._v(" – The purpose of the variable op is different. During lexing,\nwe want to determine, for each symbol read, if it’s an operator or\nnot. We can imagine that for expressions of million of characters,\nit makes us millions of tests just for the lexing. We will therefore\ngreatly reduce the number of tests by creating an array of 256\ncharacters which associate, for each operator (using the ASCII code as\nan index in the table) the number that corresponds (the one present\nin the enumeration given above) and setting the value 0 to all other\ncharacters. This allows us, first to test if a character is an operator,\nand at the same time to know the value associated (to determine which\noperator it is).")]),e._v(" "),s("p",[e._v("Finally, the public variable "),s("code",[e._v("num_")]),e._v(" will allow the parser, when the lexer\nwill return a token of type NUMBER, to get the value of the number that\nwill be presented in this variable.")]),e._v(" "),s("p",[e._v("We code, we optimize a bit and here is the result:")]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("unsigned\nLexer::get_token ()\n{\n  if (offset_ >= expr_size_)\n    return 0;\n\n  int tok = get_op_ (expr_[offset_++]);\n\n  if (tok)\n    return tok;\n\n  expr_[offset_ - 1] = table_[(int)expr_[offset_ - 1]];\n\n  num_.offset = offset_ - 1;\n  unsigned length = 1;\n\n  while (!op_[(int)expr_[offset_]])\n  {\n    expr_[offset_] = table_[(int)expr_[offset_++]];\n    length++;\n  }\n\n  num_.size = length;\n\n  return NUMBER;\n}\n")])])]),s("p",[e._v("This code is not the most optimized but in this version of the program\nwe will use it like this. Later, during the profiling phase, if it turns\nout that this is part of the program is the slowest, we could optimize\nit.")])])}),[],!1,null,null,null);t.default=a.exports}}]);